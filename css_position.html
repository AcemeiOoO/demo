<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>啊</title>

	<!-- 选择器优先级：ID选择器>类选择器>标签选择器 -->
	<!-- 内部样式表和外部样式表比较优先级 谁在后面采用谁 -->
	<!-- 
		链接式 
		1、属于XHTML
		2、优先加载CSS文件到页面
	-->
	<!-- <link type="text/css" rel="styleSheet"  href="CSS文件路径" /> -->
	<!-- 
		导入式 
		1、属于CSS2.1
		2、先加载HTML结构在加载CSS文件。
	-->
	<!-- <style type="text/css">
		@import url("css文件路径");
	</style> -->
	<style type="text/css">
		body{
			position: relative;
		}
		.container{
			position: absolute;
			width: 300px;
			height: 200px;
			left: 50px;
			border: 2px solid purple;
			background-color: aliceblue;
		}
		.date{
			/* display: none; */
			background-color: burlywood;
			margin: 10px;
			width: 400px;
			height: 300px;
		}
	</style>
</head>
<body>
	<!-- <div class="container">
		<input class="button" type="button" value="日期" onclick="showDiv()">
		<input class="button" type="button" value="关闭日期" onclick="closeDiv()">
		<div class="date">hiahiahia</div>
	</div> -->
	<button onclick="cancelSelection()">取消选中</button>
	发现
关注
消息
搜索
(一)Vue.directive指令(自定义指令)

我拥抱着我的未来
(一)Vue.directive指令(自定义指令)

我拥抱着我的未来
0.732
2018.02.14 16:56:58
字数 553
阅读 27,987
本节知识点
全局api
Vue.directive指令
自定义指令的生命周期
全局api概述
全局api并不在构造器里面，而是先声明全局变量或者直接在vue中定义一些新功能，VUE内置了一些全局api,说简单点就是在构造器外面用vue提供给我们的api函数来定义新的功能.
Vue.directive 指令
我们在第一季学习了内部指令，但是我们想要定义一个v-hello的指令，作用就是让文字变成绿色.

在开始之前先写一个小DEMO，页面上有一个数字是10，数字的下面有一个按钮，每次点击加1

代码如下

这里要说明的就是指令写的是v-hello,但是我们用directive的时候前面不用加v-了，直接输入指令即可
可以看到数字也变成绿色了，说明自定义指令也起作用了。
el : 指令所绑定的元素，可以用来直接操作DOM
binding: 一个对象，包含指令的很多信息
vnode: VUE编译生成的虚拟节点
自定义指令的生命周期
自定义指令有5个生命周期(也叫作钩子函数)分别是bind ,inserted,update,componentUpdate,unbind

要是想解绑这个vue可以使用
function unbind(){
  app.$destroy()
}
bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。

inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)

update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新

componentUpdate :被绑定的元素所在模板完成一次更新更新周期的时候调用

unbind: 只调用一次，指令月元素解绑的时候调用

见下面代码

"小礼物走一走，来简书关注我"
还没有人赞赏，支持一下
  
我拥抱着我的未来
前端路迢迢，吾无所惧
总资产144 (约14.24元)共写了9.6W字获得133个赞共119个粉丝
被以下专题收入，发现更多相似内容

前端
推荐阅读
更多精彩内容
Vue.js 1.0 Official Guide Note
Vue 实例 属性和方法 每个 Vue 实例都会代理其 data 对象里所有的属性：var data = { a:...

云之外
阅读 815
评论 0
赞 6

Vue.js 2.0 Official Guide Note
这篇笔记主要包含 Vue 2 不同于 Vue 1 或者特有的内容，还有我对于 Vue 1.0 印象不深的内容。关于...

云之外
阅读 3,298
评论 0
赞 29

angular js自定义指令 directive 如何使用？为什么要使用封装的自定义指令？
【JS-8】 angular js自定义指令 directive 如何使用？为什么要使用封装的自定义指令？ 小课堂...

爱上Shu的小刺猬
阅读 940
评论 0
赞 3
30岁，我的人生刚刚开始
前段时间歌手赵雷又被推到了风口浪尖，源于他的那首《三十岁的女人》。今天打开网页，又看到了批判赵雷的文章，一个个怒不...

军嫂梓萤
阅读 186
评论 4
赞 7

兄弟姐妹
突然看到，以前我们爬山的照片 我想你们了，我们在一起很快乐，无忧无虑。 可爱的，大豪，小豪，雨乐，雨杭，依茗，弟弟。

暖系小鱼
阅读 13
评论 0
赞 1


我拥抱着我的未来
总资产144 (约14.24元)
(十九)前端中使用amfe-flexible和postcss-pxtorem
阅读 5,487
React入门(九)Redux中间件redux-thunk
阅读 127
推荐阅读
vue点击左右按钮内容滑动
阅读 753
前端This指向
阅读 802
55行代码轻松解决websocket
阅读 355
vue TypeScript引入Echarts
阅读 72
扩展运算符...和map，filter等方法返回的数组是深拷贝么
阅读 343
写下你的评论...

    <script>
		function testSelection(e) {
			console.log('1111');
			var s = window.getSelection()
			console.log(s);
			console.log(s.toString());
		}
		window.addEventListener('mouseup',testSelection,false)

		function cancelSelection() {
			// document.style.userSelect = 'none';
			// 取消文本选中   "getSelection" in window      ->   document.selection.empty();
			// window.getSelection().removeAllRanges();
			// window.getSelection().empty();
			// console.log(window.getSelection().anchorNode,window.getSelection().focusNode);
			// console.log(window.getSelection().collapseToEnd());
			console.log(window.getSelection().rangeCount);
			console.log(window.getSelection().getRangeAt(0));
			
		}
	</script>
	<!-- <script type="text/javascript">
		function showDiv() {
			document.querySelector('.date').style.display = 'block';
			console.log('showDiv',document.querySelector('.container').style.display);
		}
		function closeDiv() {
			document.querySelector('.date').style.display = 'none';
			console.log('closeDiv',document.querySelector('.container').style.display);
		}

		// document.querySelector('.container').addEventListener('mousedown',doDown,false);
		// document.querySelector('.container').addEventListener('mousemove',doMove,false);
		// document.querySelector('.container').addEventListener('mouseup',doUp,false);

		// function doMove(e) {
			
		// }


		// 整体可拖动
		document.querySelector('.container').addEventListener('mousedown',drag,false);
		document.querySelector('.container').addEventListener('mousemove',drag,false);
		document.querySelector('.container').addEventListener('mouseup',drag,false);
		var flag = false;
		var mouseX = -1;
		var mouseY = -1;
		var divPositionX = -1;
		var divPositionY = -1;
		function drag(e) {
			var e = e || window.event;
			e.preventDefault();
			switch(e.type){
				case 'mousedown':
					flag = true;
					el = e.target;
					el.style.cursor = "move";
					el.style.zIndex = '9';
					//鼠标点中目标元素时鼠标在页面中的位置
					mouseX = e.clientX;
                    mouseY = e.clientY;
					//鼠标点中目标元素时元素的位置
					divPositionX = el.offsetLeft;
					divPositionY = el.offsetTop;
					console.log('mouseX mouseY divPositionX divPositionY',mouseX,mouseY,divPositionX,divPositionY);
					break;
				case 'mousemove':
					if (flag) {
                        var left, top;
						left = e.clientX - mouseX;
						top = e.clientY - mouseY;
						console.log('left top',left,top);

                        el.style.left = left + divPositionX + 'px';
                        el.style.top = top + divPositionY + 'px';
						console.log('el.style.left el.style.top',el.style.left,el.style.top);
                    }
					break;
				case 'mouseup':
					flag = false;
                    el.style.cursor = "auto";
                    console.log('鼠标抬起');
                    document.onmousemove = null;
                    document.onmouseup = null;
                    break;
			}
		}
	</script> -->
</body>
</html>